#############################################
# SERVER / PUERTO
#############################################

# Usa el puerto que Railway inyecta (PORT). Si no existe, 8080.
server.port=${PORT:8080}


#############################################
# DATASOURCE (MySQL)
#############################################
# Orden de resolución para la URL:
# 1) SPRING_DATASOURCE_URL (la que ya definiste en Railway)
# 2) Construida con envs nativas de Railway (MYSQLHOST, MYSQLPORT, MYSQLDATABASE)
# 3) Valor fijo legacy como último fallback.

spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:mysql://${MYSQLHOST:${RAILWAY_PRIVATE_DOMAIN}}:${MYSQLPORT:3306}/${MYSQLDATABASE:railway}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC}

# Usuario:
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:${MYSQLUSER:root}}

# Password (sin default por seguridad: si falta, que falle):
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:${MYSQLPASSWORD}}

# (Opcional) Spring Boot detecta el driver solo con mysql-connector-j en el classpath.
# spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver


#############################################
# JPA / HIBERNATE
#############################################

# "update" crea/actualiza tablas sin borrar datos. Puedes pasarla por env:
# SPRING_JPA_HIBERNATE_DDL_AUTO=update
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}

# Mostrar SQL en logs (controlable por env SPRING_JPA_SHOW_SQL=true/false)
spring.jpa.show-sql=${SPRING_JPA_SHOW_SQL:true}

# Dialecto explícito de MySQL (Hibernate 6 usa MySQLDialect genérico).
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# Formatear SQL y evitar Open-Session-In-View
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.open-in-view=false


#############################################
# HikariCP (pool de conexiones)
#############################################

# Tamaños conservadores para tiers pequeños.
spring.datasource.hikari.maximum-pool-size=${DB_POOL_MAX:5}
spring.datasource.hikari.minimum-idle=${DB_POOL_MIN_IDLE:2}

# Tiempos razonables para cloud.
spring.datasource.hikari.connection-timeout=${DB_POOL_CONN_TIMEOUT_MS:30000}
spring.datasource.hikari.idle-timeout=${DB_POOL_IDLE_TIMEOUT_MS:600000}
spring.datasource.hikari.max-lifetime=${DB_POOL_MAX_LIFETIME_MS:1800000}

# Si quieres que no reviente el arranque si no conecta de inmediato:
# spring.datasource.hikari.initialization-fail-timeout=0


#############################################
# INIT SQL (deshabilitado por defecto)
#############################################

spring.sql.init.mode=never


#############################################
# ACTUATOR (salud básica)
#############################################

management.endpoints.web.exposure.include=health,info
management.endpoint.health.probes.enabled=true
management.health.db.enabled=true


#############################################
# FALLBACK OPCIONAL: TCP PROXY PÚBLICO (COMENTADO)
#############################################
# Úsalo solo si el host interno no te resuelve y necesitas salir por proxy público.
# Requiere que la DB esté expuesta con TCP Proxy en Railway.
#
# spring.datasource.url=jdbc:mysql://${RAILWAY_TCP_PROXY_DOMAIN}:${RAILWAY_TCP_PROXY_PORT}/${MYSQLDATABASE:railway}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC
