#############################################
# SERVER / PUERTO
#############################################

# Usa el puerto que asigna Railway (PORT). Si no existe, cae en 8080.
server.port=${PORT:8080}


#############################################
# DATASOURCE (MySQL en Railway)
#############################################

# URL JDBC. Toma primero la var de entorno SPRING_DATASOURCE_URL; si no existe,
# usa un valor por defecto que apunta al host interno de Railway.
# allowPublicKeyRetrieval=true ayuda con MySQL 8 en entornos cloud.
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:mysql://mysql.railway.internal:3306/railway?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC}

# Usuario de la DB (por defecto "root" en Railway).
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:root}

# Password de la DB. No le pongo valor por defecto por seguridad.
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}

# (Opcional) Spring detecta el driver automáticamente; descomenta si lo necesitas.
# spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver


#############################################
# JPA / HIBERNATE
#############################################

# Estrategia de schema. Lee SPRING_JPA_HIBERNATE_DDL_AUTO o usa "update".
# "update" crea/actualiza tablas sin borrar datos (útil para dev).
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}

# Muestra las sentencias SQL en logs si SPRING_JPA_SHOW_SQL es true (por defecto true aquí).
spring.jpa.show-sql=${SPRING_JPA_SHOW_SQL:true}

# Dialecto de MySQL (Hibernate). Ayuda a generar SQL óptimo.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# Formatea el SQL en logs para hacerlo legible.
spring.jpa.properties.hibernate.format_sql=true

# Buenas prácticas: desactivar Open Session in View (evita LazyInitialization surprises).
spring.jpa.open-in-view=false


#############################################
# POOL DE CONEXIONES (HikariCP)
#############################################

# Tamaño máximo del pool. Ajusta según tu carga; Railway free/low tiers suelen ir bien con 5–10.
spring.datasource.hikari.maximum-pool-size=${DB_POOL_MAX:5}

# Conexiones mínimas inactivas.
spring.datasource.hikari.minimum-idle=${DB_POOL_MIN_IDLE:2}

# Timeout al pedir conexión (ms).
spring.datasource.hikari.connection-timeout=${DB_POOL_CONN_TIMEOUT_MS:30000}

# Tiempo máximo que una conexión puede estar inactiva (ms).
spring.datasource.hikari.idle-timeout=${DB_POOL_IDLE_TIMEOUT_MS:600000}

# Vida máxima de una conexión (ms). Evita “stale” sockets en proveedores cloud.
spring.datasource.hikari.max-lifetime=${DB_POOL_MAX_LIFETIME_MS:1800000}


#############################################
# INICIALIZACIÓN SQL
#############################################

# No ejecutar scripts schema.sql/data.sql automáticamente (cámbialo a "always" si los usas).
spring.sql.init.mode=never


#############################################
# ACTUATOR (SALUD BÁSICA)
#############################################

management.endpoints.web.exposure.include=health,info


management.endpoint.health.probes.enabled=true


management.health.db.enabled=true


